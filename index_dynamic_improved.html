<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic Load Balancer Visualization</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f8f9fa;
      padding: 20px;
      color: #333;
      margin: 0;
    }
    h1 {
      text-align: center;
      margin-bottom: 30px;
      color: #2c3e50;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
      position: relative;
    }
    .system-container {
      display: flex;
      width: 100%;
      gap: 40px;
      align-items: center;
      justify-content: space-between;
      position: relative;
    }
    .load-balancer {
      width: 160px;
      height: 160px;
      background-color: #9b59b6;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      position: relative;
      transition: transform 0.2s;
    }
    .load-balancer:hover {
      transform: scale(1.03);
    }
    .load-balancer-icon {
      font-size: 40px;
      margin-bottom: 10px;
    }
    .workers-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
    }
    .worker {
      width: 120px;
      height: 120px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      font-weight: bold;
      color: white;
      transition: all 0.3s;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      position: relative;
    }
    .worker-icon {
      font-size: 30px;
      margin-bottom: 5px;
    }
    .worker .status {
      font-size: 12px;
      margin-top: 5px;
    }
    .worker .load {
      font-size: 11px;
      margin-top: 2px;
    }
    .worker .pid {
      font-size: 11px;
      margin-top: 2px;
      opacity: 0.8;
    }
    .idle {
      background-color: #2ecc71;
    }
    .light {
      background-color: #27ae60;
    }
    .medium {
      background-color: #f39c12;
    }
    .heavy {
      background-color: #e67e22;
    }
    .busy {
      background-color: #e74c3c;
    }
    .requests-panel {
      background-color: white;
      border-radius: 10px;
      padding: 15px;
      width: 100%;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }
    .request-controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 10px 20px;
      font-size: 14px;
      cursor: pointer;
      background-color: #9b59b6;
      color: white;
      border: none;
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #8e44ad;
    }
    button:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
    }
    .requests-info {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
    }
    .requests-log {
      max-height: 200px;
      overflow-y: auto;
      border-top: 1px solid #eee;
      padding-top: 10px;
    }
    .log-entry {
      padding: 8px;
      margin-bottom: 5px;
      border-radius: 5px;
      font-size: 14px;
      display: flex;
      align-items: center;
    }
    .log-entry.sent {
      background-color: #eaf2fd;
    }
    .log-entry.assigned {
      background-color: #e8f5e9;
    }
    .log-entry.completed {
      background-color: #eafaef;
    }
    .log-entry.error {
      background-color: #fdeeee;
    }
    .log-time {
      color: #7f8c8d;
      margin-right: 10px;
      font-size: 12px;
    }
    .request-ball-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      overflow: visible;
    }
    .request-ball {
      position: absolute;
      width: 15px;
      height: 15px;
      background-color: #9b59b6;
      border-radius: 50%;
      z-index: 100;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
    }
    .load-indicator {
      position: absolute;
      width: 90%;
      height: 8px;
      bottom: 10px;
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      overflow: hidden;
    }
    .load-bar {
      height: 100%;
      background-color: rgba(255, 255, 255, 0.7);
      border-radius: 4px;
      transition: width 0.5s;
    }
    .counters {
      display: flex;
      gap: 20px;
      margin-top: 10px;
    }
    .counter {
      background-color: #f8f9fa;
      border-radius: 5px;
      padding: 10px;
      flex: 1;
      text-align: center;
    }
    .counter-value {
      font-size: 24px;
      font-weight: bold;
      color: #2c3e50;
    }
    .counter-label {
      font-size: 12px;
      color: #7f8c8d;
      margin-top: 5px;
    }
    .algorithm-info {
      background-color: #f0e6f6;
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 20px;
      border-left: 5px solid #9b59b6;
    }
    .algorithm-title {
      font-weight: bold;
      margin-bottom: 5px;
      color: #2c3e50;
    }
  </style>
</head>
<body>
  <h1>Dynamic Load Balancer Visualization</h1>
  <div class="container">
    <div class="algorithm-info">
      <div class="algorithm-title">Dynamic Load Balancing Algorithm:</div>
      <div>This load balancer assigns incoming requests to workers based on their current load. Requests are assigned to the worker with the lowest workload, minimizing wait times and balancing system resources effectively.</div>
    </div>
    
    <div class="system-container">
      <div class="load-balancer">
        <div class="load-balancer-icon">⚖️</div>
        <div>Dynamic Balancer</div>
        <div style="font-size: 12px; margin-top: 5px;">Master Process</div>
      </div>
      
      <div class="workers-container">
        <div id="worker1" class="worker idle">
          <div class="worker-icon">⚙️</div>
          <div>Worker 1</div>
          <div class="status">Idle</div>
          <div class="load">Load: 0%</div>
          <div class="pid" id="pid1">PID: -</div>
          <div class="load-indicator">
            <div class="load-bar" style="width: 0%"></div>
          </div>
        </div>
        <div id="worker2" class="worker idle">
          <div class="worker-icon">⚙️</div>
          <div>Worker 2</div>
          <div class="status">Idle</div>
          <div class="load">Load: 0%</div>
          <div class="pid" id="pid2">PID: -</div>
          <div class="load-indicator">
            <div class="load-bar" style="width: 0%"></div>
          </div>
        </div>
        <div id="worker3" class="worker idle">
          <div class="worker-icon">⚙️</div>
          <div>Worker 3</div>
          <div class="status">Idle</div>
          <div class="load">Load: 0%</div>
          <div class="pid" id="pid3">PID: -</div>
          <div class="load-indicator">
            <div class="load-bar" style="width: 0%"></div>
          </div>
        </div>
        <div id="worker4" class="worker idle">
          <div class="worker-icon">⚙️</div>
          <div>Worker 4</div>
          <div class="status">Idle</div>
          <div class="load">Load: 0%</div>
          <div class="pid" id="pid4">PID: -</div>
          <div class="load-indicator">
            <div class="load-bar" style="width: 0%"></div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Container for request animation balls -->
    <div id="request-ball-container" class="request-ball-container"></div>
    
    <div class="requests-panel">
      <div class="request-controls">
        <button id="singleRequestBtn" onclick="sendSingleRequest()">Send Single Request</button>
        <button id="burstRequestBtn" onclick="sendBurstRequests()">Send Burst (5 Requests)</button>
        <button id="startSpamBtn" onclick="startSpamRequests()">Send Repeated Requests</button>
        <button id="stopSpamBtn" onclick="stopSpamRequests()" disabled>Stop Repeated Requests</button>
      </div>
      
      <div class="counters">
        <div class="counter">
          <div class="counter-value" id="totalCounter">0</div>
          <div class="counter-label">Total Requests</div>
        </div>
        <div class="counter">
          <div class="counter-value" id="completedCounter">0</div>
          <div class="counter-label">Completed</div>
        </div>
        <div class="counter">
          <div class="counter-value" id="activeCounter">0</div>
          <div class="counter-label">Active</div>
        </div>
        <div class="counter">
          <div class="counter-value" id="avgResponseTime">0</div>
          <div class="counter-label">Avg Response (ms)</div>
        </div>
      </div>
      
      <div class="requests-log" id="requestsLog">
        <!-- Log entries will be added here -->
      </div>
    </div>
  </div>

  <script>
    let interval = null;
    let requestId = 0;
    let activeRequests = {};
    let workerLoads = {};
    let totalRequests = 0;
    let completedRequests = 0;
    let totalResponseTime = 0;
    const workerPids = {};
    
    // Get position of element in viewport
    function getAbsolutePosition(element) {
      const rect = element.getBoundingClientRect();
      
      return {
        x: rect.left + window.scrollX + rect.width / 2,
        y: rect.top + window.scrollY + rect.height / 2
      };
    }
    
    // Animate request from balancer to worker
    function animateToWorker(requestIdForAnimation, workerElement) {
      const balancer = document.querySelector('.load-balancer');
      const ballContainer = document.getElementById('request-ball-container');
      
      // Get absolute positions in the viewport
      const balancerPos = getAbsolutePosition(balancer);
      const workerPos = getAbsolutePosition(workerElement);
      
      // Calculate start and end positions
      const startX = balancerPos.x;
      const startY = balancerPos.y;
      
      const endX = workerPos.x;
      const endY = workerPos.y;
      
      // Create request ball
      const ball = document.createElement('div');
      ball.className = 'request-ball';
      ball.id = `request-${requestIdForAnimation}`;
      ballContainer.appendChild(ball);
      
      // Start position
      ball.style.left = `${startX}px`;
      ball.style.top = `${startY}px`;
      
      // Animation
      const startTime = performance.now();
      const duration = 600; // Animation duration in milliseconds
      
      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        const currentX = startX + (endX - startX) * progress;
        const currentY = startY + (endY - startY) * progress;
        
        ball.style.left = `${currentX}px`;
        ball.style.top = `${currentY}px`;
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          // Pulse effect at destination
          ball.style.transform = 'translate(-50%, -50%) scale(1.5)';
          ball.style.opacity = '0';
          ball.style.transition = 'transform 0.3s, opacity 0.3s';
          
          // Remove ball after animation completes
          setTimeout(() => {
            ball.remove();
          }, 300);
        }
      }
      
      requestAnimationFrame(animate);
    }
    
    // Add log entry
    function addLogEntry(message, type = 'sent') {
      const log = document.getElementById('requestsLog');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      
      // Create timestamp
      const now = new Date();
      const time = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
      
      entry.innerHTML = `<span class="log-time">${time}</span> ${message}`;
      log.insertBefore(entry, log.firstChild);
      
      // Limit log entries
      if (log.children.length > 50) {
        log.removeChild(log.lastChild);
      }
    }
    
    // Get load class based on percentage
    function getLoadClass(loadPercentage) {
      if (loadPercentage === 0) return 'idle';
      if (loadPercentage < 25) return 'light';
      if (loadPercentage < 50) return 'medium';
      if (loadPercentage < 75) return 'heavy';
      return 'busy';
    }
    
    // Update worker display
    function updateWorkerDisplay(workers) {
      let activeTasks = 0;
      
      for (const [pid, workerInfo] of Object.entries(workers)) {
        // Find which worker this PID belongs to
        let workerIdx = -1;
        for (const [idx, workerPid] of Object.entries(workerPids)) {
          if (workerPid === pid) {
            workerIdx = parseInt(idx);
            break;
          }
        }
        
        if (workerIdx === -1) {
          // Need to assign this PID to a worker
          for (let i = 1; i <= 4; i++) {
            if (!Object.values(workerPids).includes(pid) && !workerPids[i]) {
              workerPids[i] = pid;
              workerIdx = i;
              document.getElementById(`pid${i}`).textContent = `PID: ${pid}`;
              break;
            }
          }
        }
        
        if (workerIdx > 0) {
          const load = workerInfo.load || 0;
          const workerBox = document.getElementById(`worker${workerIdx}`);
          const statusText = workerBox.querySelector('.status');
          const loadText = workerBox.querySelector('.load');
          const loadBar = workerBox.querySelector('.load-bar');
          
          // Update load
          loadText.textContent = `Load: ${load}%`;
          loadBar.style.width = `${load}%`;
          
          // Update class based on load
          const loadClass = getLoadClass(load);
          workerBox.className = `worker ${loadClass}`;
          
          // Update status text
          if (load === 0) {
            statusText.textContent = 'Idle';
          } else if (load < 25) {
            statusText.textContent = 'Light';
            activeTasks++;
          } else if (load < 50) {
            statusText.textContent = 'Medium';
            activeTasks++;
          } else if (load < 75) {
            statusText.textContent = 'Heavy';
            activeTasks++;
          } else {
            statusText.textContent = 'Busy';
            activeTasks++;
          }
          
          // Store load info
          workerLoads[pid] = load;
        }
      }
      
      // Update active counter
      document.getElementById('activeCounter').textContent = activeTasks;
    }
    
    // Update counters
    function updateCounters() {
      document.getElementById('totalCounter').textContent = totalRequests;
      document.getElementById('completedCounter').textContent = completedRequests;
      
      // Update average response time
      const avgTime = completedRequests > 0 ? Math.round(totalResponseTime / completedRequests) : 0;
      document.getElementById('avgResponseTime').textContent = avgTime;
    }
    
    // Send a single request
    async function sendSingleRequest() {
      const currentRequestId = ++requestId;
      totalRequests++;
      
      addLogEntry(`Request #${currentRequestId} sent to load balancer`, 'sent');
      updateCounters();
      
      try {
        const startTime = performance.now();
        const response = await fetch("http://localhost:3000/load");
        const responseTime = Math.round(performance.now() - startTime);
        
        const text = await response.text();
        
        if (response.status === 200) {
          // Extract the PID and load from the response
          const pidMatch = text.match(/Worker (\d+)/);
          const loadMatch = text.match(/load: (\d+)%/);
          
          let workerPid = null;
          let load = 0;
          
          if (pidMatch && pidMatch[1]) {
            workerPid = pidMatch[1];
            
            if (loadMatch && loadMatch[1]) {
              load = parseInt(loadMatch[1]);
            }
            
            // Find worker element
            let workerElement = null;
            let workerIndex = null;
            
            for (const [idx, pid] of Object.entries(workerPids)) {
              if (pid === workerPid) {
                workerIndex = idx;
                workerElement = document.getElementById(`worker${idx}`);
                break;
              }
            }
            
            if (!workerElement) {
              // If we don't have this PID mapped yet, assign to a worker
              for (let i = 1; i <= 4; i++) {
                if (!workerPids[i]) {
                  workerElement = document.getElementById(`worker${i}`);
                  workerIndex = i;
                  workerPids[i] = workerPid;
                  document.getElementById(`pid${i}`).textContent = `PID: ${workerPid}`;
                  break;
                }
              }
            }
            
            if (workerElement) {
              // Store the request
              activeRequests[currentRequestId] = {
                workerId: workerIndex,
                pid: workerPid,
                startTime: new Date(),
                responseTime: responseTime
              };
              
              // Animate the request to worker
              animateToWorker(currentRequestId, workerElement);
              
              addLogEntry(`Request #${currentRequestId} assigned to Worker ${workerIndex} (PID: ${workerPid}, load: ${load}%)`, 'assigned');
            }
          }
        } else {
          addLogEntry(`Request #${currentRequestId} failed with status ${response.status}`, 'error');
        }
        
        await updateWorkerStatus();
      } catch (e) {
        addLogEntry(`Request #${currentRequestId} failed: ${e.message}`, 'error');
      }
    }
    
    // Send a burst of requests
    async function sendBurstRequests() {
      const burstSize = 5;
      
      for (let i = 0; i < burstSize; i++) {
        await sendSingleRequest();
        // Small delay between requests to see the animations
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }
    
    // Start repeated requests
    function startSpamRequests() {
      if (interval) return;
      
      document.getElementById('startSpamBtn').disabled = true;
      document.getElementById('stopSpamBtn').disabled = false;
      
      interval = setInterval(sendSingleRequest, 1000);
      addLogEntry('Started sending repeated requests', 'info');
    }
    
    // Stop repeated requests
    function stopSpamRequests() {
      clearInterval(interval);
      interval = null;
      
      document.getElementById('startSpamBtn').disabled = false;
      document.getElementById('stopSpamBtn').disabled = true;
      
      addLogEntry('Stopped sending repeated requests', 'info');
    }
    
    // Update worker statuses
    async function updateWorkerStatus() {
      try {
        const res = await fetch("http://localhost:3000/status");
        const data = await res.json();
        
        // Track worker loads
        const currentWorkerStatus = {};
        for (const [pid, workerInfo] of Object.entries(data.workers)) {
          currentWorkerStatus[pid] = workerInfo;
          
          // If the worker was previously loaded but now has no tasks, check if requests completed
          if (workerLoads[pid] > 0 && workerInfo.load === 0) {
            // Find requests that were assigned to this worker
            Object.entries(activeRequests).forEach(([reqId, request]) => {
              if (request.pid === pid) {
                completedRequests++;
                totalResponseTime += request.responseTime;
                
                addLogEntry(`Request #${reqId} completed by Worker ${request.workerId} (PID: ${pid}) in ${request.responseTime}ms`, 'completed');
                delete activeRequests[reqId];
                updateCounters();
              }
            });
          }
        }
        
        updateWorkerDisplay(data.workers);
      } catch (e) {
        console.error("Failed to update status:", e);
      }
    }
    
    // Initial setup
    window.onload = function() {
      // Set up ball container to cover the entire viewport
      const ballContainer = document.getElementById('request-ball-container');
      ballContainer.style.width = '100%';
      ballContainer.style.height = '100%';
      ballContainer.style.position = 'fixed';
      ballContainer.style.top = '0';
      ballContainer.style.left = '0';
      ballContainer.style.zIndex = '1000';
      ballContainer.style.pointerEvents = 'none';
      
      setInterval(updateWorkerStatus, 500);
      updateWorkerStatus();
    };
  </script>
</body>
</html>