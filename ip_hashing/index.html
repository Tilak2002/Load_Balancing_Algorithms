<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IP Hashing Load Balancer Visualization</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f8f9fa;
      padding: 20px;
      color: #333;
      margin: 0;
    }
    h1 {
      text-align: center;
      margin-bottom: 10px;
      color: #2c3e50;
    }
    .description {
      text-align: center;
      margin-bottom: 30px;
      color: #555;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
      position: relative;
    }
    .algorithm-info {
      background-color: #eaf2fd;
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 20px;
      border-left: 5px solid #3498db;
      max-width: 800px;
      width: 100%;
    }
    .algorithm-title {
      font-weight: bold;
      margin-bottom: 5px;
      color: #2c3e50;
    }
    .system-container {
      display: flex;
      width: 100%;
      gap: 40px;
      align-items: center;
      justify-content: space-between;
      position: relative;
    }
    .load-balancer {
      width: 160px;
      height: 160px;
      background-color: #3498db;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      position: relative;
      transition: transform 0.2s;
    }
    .load-balancer:hover {
      transform: scale(1.03);
    }
    .load-balancer-icon {
      font-size: 40px;
      margin-bottom: 10px;
    }
    .workers-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
    }
    .worker {
      width: 120px;
      height: 120px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      font-weight: bold;
      color: white;
      transition: all 0.3s;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      position: relative;
    }
    .worker-icon {
      font-size: 30px;
      margin-bottom: 5px;
    }
    .worker .status {
      font-size: 12px;
      margin-top: 5px;
    }
    .worker .load {
      font-size: 16px;
      margin-top: 2px;
    }
    .worker .pid {
      font-size: 11px;
      margin-top: 2px;
      opacity: 0.8;
    }
    .idle {
      background-color: #2ecc71;
    }
    .busy {
      background-color: #e74c3c;
    }
    .status-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    .status-indicator.idle {
      background-color: #2ecc71;
    }
    .status-indicator.busy {
      background-color: #e74c3c;
    }
    .requests-panel {
      background-color: white;
      border-radius: 10px;
      padding: 15px;
      width: 100%;
      max-width: 800px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }
    .request-controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 10px 20px;
      font-size: 14px;
      cursor: pointer;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #2980b9;
    }
    button:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
    }
    .ip-selection {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      margin-bottom: 20px;
    }
    .ip-selection label {
      font-weight: bold;
    }
    .ip-selection select {
      padding: 8px;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    .counters {
      display: flex;
      justify-content: space-around;
      gap: 10px;
      margin-top: 10px;
      margin-bottom: 20px;
    }
    .counter {
      background-color: #f8f9fa;
      border-radius: 5px;
      padding: 10px;
      flex: 1;
      text-align: center;
    }
    .counter-value {
      font-size: 24px;
      font-weight: bold;
      color: #2c3e50;
    }
    .counter-label {
      font-size: 12px;
      color: #7f8c8d;
      margin-top: 5px;
    }
    .logs {
      max-height: 200px;
      overflow-y: auto;
      border-top: 1px solid #eee;
      padding-top: 10px;
    }
    .log-entry {
      padding: 8px;
      margin-bottom: 5px;
      border-radius: 5px;
      font-size: 14px;
      display: flex;
      align-items: center;
    }
    .log-entry.sent {
      background-color: #eaf2fd;
    }
    .log-entry.completed {
      background-color: #eafaef;
    }
    .log-entry.error {
      background-color: #fdeeee;
    }
    .log-time {
      color: #7f8c8d;
      margin-right: 10px;
      font-size: 12px;
    }
    .request-ball {
      position: absolute;
      width: 15px;
      height: 15px;
      background-color: #f39c12;
      border-radius: 50%;
      z-index: 100;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
      pointer-events: none;
    }
    .job-info {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 255, 255, 0.9);
      padding: 3px 6px;
      border-radius: 3px;
      font-size: 10px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      white-space: nowrap;
    }
    .hash-details {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 10px;
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      font-size: 12px;
      z-index: 20;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .load-balancer:hover .hash-details {
      opacity: 1;
    }
  </style>
</head>
<body>
  <h1>IP Hashing Load Balancer Visualization</h1>
  <div class="container">
    <div class="algorithm-info">
      <div class="algorithm-title">IP Hashing Algorithm:</div>
      <div>In this load balancing strategy, the client's IP address is hashed to consistently route requests from the same client to the same worker. This maintains session affinity without requiring shared state, making it ideal for stateful applications where client context needs to stay on the same server.</div>
    </div>
    
    <div class="system-container">
      <div class="load-balancer">
        <div class="load-balancer-icon">üìä</div>
        <div>Load Balancer</div>
        <div style="font-size: 12px; margin-top: 5px;">Master Process</div>
        <div class="hash-details" id="hashDetails">
          IP Hash Calculation:
          <br>
          <span id="hashFormula"></span>
        </div>
      </div>
      
      <div class="workers-container">
        <div id="worker1" class="worker idle">
          <div class="worker-icon">‚öôÔ∏è</div>
          <div>Worker 1</div>
          <div class="status">Idle</div>
          <div class="load" id="load-1">0 ms</div>
          <div class="pid" id="pid1">PID: -</div>
          <div class="status-indicator idle"></div>
        </div>
        <div id="worker2" class="worker idle">
          <div class="worker-icon">‚öôÔ∏è</div>
          <div>Worker 2</div>
          <div class="status">Idle</div>
          <div class="load" id="load-2">0 ms</div>
          <div class="pid" id="pid2">PID: -</div>
          <div class="status-indicator idle"></div>
        </div>
        <div id="worker3" class="worker idle">
          <div class="worker-icon">‚öôÔ∏è</div>
          <div>Worker 3</div>
          <div class="status">Idle</div>
          <div class="load" id="load-3">0 ms</div>
          <div class="pid" id="pid3">PID: -</div>
          <div class="status-indicator idle"></div>
        </div>
        <div id="worker4" class="worker idle">
          <div class="worker-icon">‚öôÔ∏è</div>
          <div>Worker 4</div>
          <div class="status">Idle</div>
          <div class="load" id="load-4">0 ms</div>
          <div class="pid" id="pid4">PID: -</div>
          <div class="status-indicator idle"></div>
        </div>
      </div>
    </div>
    
    <div class="requests-panel">
      <div class="ip-selection">
        <label for="clientIP">Client IP:</label>
        <select id="clientIP">
          <option value="192.168.1.101">192.168.1.101</option>
          <option value="192.168.1.102">192.168.1.102</option>
          <option value="192.168.1.103">192.168.1.103</option>
          <option value="192.168.1.104">192.168.1.104</option>
          <option value="192.168.1.105">192.168.1.105</option>
          <option value="10.0.0.1">10.0.0.1</option>
          <option value="10.0.0.2">10.0.0.2</option>
          <option value="172.16.0.1">172.16.0.1</option>
        </select>
      </div>
      
      <div class="request-controls">
        <button id="singleRequestBtn" onclick="sendRequest()">Send Single Request</button>
        <button id="startSpamBtn" onclick="startSpam()">Send Repeated Requests</button>
        <button id="stopSpamBtn" onclick="stopSpam()" disabled>Stop Repeated Requests</button>
      </div>
      
      <div class="counters">
        <div class="counter">
          <div class="counter-value" id="totalCounter">0</div>
          <div class="counter-label">Total Requests</div>
        </div>
        <div class="counter">
          <div class="counter-value" id="completedCounter">0</div>
          <div class="counter-label">Completed</div>
        </div>
        <div class="counter">
          <div class="counter-value" id="avgTimeCounter">0</div>
          <div class="counter-label">Avg. Processing Time (ms)</div>
        </div>
      </div>
      
      <div class="logs" id="logContainer">
        <!-- Log entries will be added here -->
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let spamInterval = null;
    let requestId = 0;
    let totalRequests = 0;
    let completedRequests = 0;
    let totalProcessingTime = 0;
    const workerPids = {};
    const activeRequests = {};
    const workerLoads = {};
    const workerIPMappings = {};
    
    // Get position of element relative to the document
    function getAbsolutePosition(element) {
      const rect = element.getBoundingClientRect();
      return {
        x: rect.left + window.scrollX + rect.width / 2,
        y: rect.top + window.scrollY + rect.height / 2
      };
    }
    
    // Hash IP function (same as server)
    function hashIP(ip) {
      return ip.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
    }
    
    // Calculate worker index from IP
    function getWorkerIndexFromIP(ip) {
      const hash = hashIP(ip);
      return (hash % 4) + 1; // 1-based index for worker display
    }
    
    // Show hash calculation details
    function updateHashDetails(ip) {
      const hashValue = hashIP(ip);
      const workerIndex = getWorkerIndexFromIP(ip);
      
      let formula = `IP: ${ip}<br>`;
      formula += `Hash: ${ip} ‚Üí ${hashValue}<br>`;
      formula += `Index: ${hashValue} % 4 = ${workerIndex}`;
      
      document.getElementById('hashFormula').innerHTML = formula;
    }
    
    // Animate request from load balancer to worker
    function animateRequest(requestIdForAnimation, processingTime, workerElement, clientIP) {
      const balancer = document.querySelector('.load-balancer');
      const container = document.querySelector('.container');
      
      // Update hash calculation display
      updateHashDetails(clientIP);
      
      // Create request ball
      const ball = document.createElement('div');
      ball.className = 'request-ball';
      ball.id = `request-${requestIdForAnimation}`;
      document.body.appendChild(ball);
      
      // Add job info
      const jobInfo = document.createElement('div');
      jobInfo.className = 'job-info';
      jobInfo.textContent = `${processingTime} ms | ${clientIP}`;
      ball.appendChild(jobInfo);
      
      // Get positions for animation
      const balancerPos = getAbsolutePosition(balancer);
      const workerPos = getAbsolutePosition(workerElement);
      
      // Set initial position
      ball.style.left = `${balancerPos.x}px`;
      ball.style.top = `${balancerPos.y}px`;
      
      // Animation
      const startTime = performance.now();
      const duration = 600; // Animation duration in milliseconds
      
      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        const currentX = balancerPos.x + (workerPos.x - balancerPos.x) * progress;
        const currentY = balancerPos.y + (workerPos.y - balancerPos.y) * progress;
        
        ball.style.left = `${currentX}px`;
        ball.style.top = `${currentY}px`;
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          // Pulse effect at destination
          ball.style.transform = 'translate(-50%, -50%) scale(1.5)';
          ball.style.opacity = '0';
          ball.style.transition = 'transform 0.3s, opacity 0.3s';
          
          // Remove ball after animation completes
          setTimeout(() => {
            ball.remove();
          }, 300);
        }
      }
      
      requestAnimationFrame(animate);
    }
    
    // Add log entry
    function addLogEntry(message, type = 'sent') {
      const log = document.getElementById('logContainer');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      
      // Create timestamp
      const now = new Date();
      const time = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
      
      entry.innerHTML = `<span class="log-time">${time}</span> ${message}`;
      log.insertBefore(entry, log.firstChild);
      
      // Limit log entries
      if (log.children.length > 50) {
        log.removeChild(log.lastChild);
      }
    }
    
    // Update counters
    function updateCounters() {
      document.getElementById('totalCounter').textContent = totalRequests;
      document.getElementById('completedCounter').textContent = completedRequests;
      
      if (completedRequests > 0) {
        const avgTime = Math.round(totalProcessingTime / completedRequests);
        document.getElementById('avgTimeCounter').textContent = avgTime;
      }
    }
    
    // Handle window resize to reposition elements if needed
    window.addEventListener('resize', function() {
      // This ensures animations will use updated positions after resize
    });
    
    // Send a single request
    async function sendRequest() {
      const currentRequestId = ++requestId;
      totalRequests++;
      updateCounters();
      
      // Get selected IP
      const clientIP = document.getElementById('clientIP').value;
      const workerIndex = getWorkerIndexFromIP(clientIP);
      
      try {
        // For simulation purposes, we'll generate a random processing time
        const processingTime = Math.floor(1000 + Math.random() * 4000);
        
        // Assign worker PID if not already assigned
        if (!workerPids[workerIndex]) {
          // Simulate PID creation
          const pid = Math.floor(10000 + Math.random() * 90000);
          workerPids[workerIndex] = pid.toString();
          document.getElementById(`pid${workerIndex}`).textContent = `PID: ${pid}`;
        }
        
        const workerPid = workerPids[workerIndex];
        const workerElement = document.getElementById(`worker${workerIndex}`);
        
        // Update worker status
        if (!workerLoads[workerPid]) {
          workerLoads[workerPid] = 0;
        }
        workerLoads[workerPid] += processingTime;
        
        // Store IP to worker mapping
        if (!workerIPMappings[clientIP]) {
          workerIPMappings[clientIP] = workerIndex;
        }
        
        updateWorkerDisplays();
        
        // Store active request
        activeRequests[currentRequestId] = {
          pid: workerPid,
          workerIndex,
          processingTime,
          startTime: Date.now(),
          clientIP
        };
        
        // Animate request to worker
        animateRequest(currentRequestId, processingTime, workerElement, clientIP);
        
        addLogEntry(`Request #${currentRequestId} from ${clientIP} (${processingTime}ms) routed to Worker ${workerIndex} (PID: ${workerPid})`, 'sent');
        
        // Schedule request completion (simulation)
        setTimeout(() => {
          completeRequest(currentRequestId);
        }, processingTime);
      } catch (err) {
        addLogEntry(`Error sending request: ${err.message}`, 'error');
      }
    }
    
    // Complete a request (for visualization purposes)
    function completeRequest(reqId) {
      const request = activeRequests[reqId];
      if (request) {
        workerLoads[request.pid] -= request.processingTime;
        if (workerLoads[request.pid] < 0) workerLoads[request.pid] = 0;
        
        completedRequests++;
        totalProcessingTime += request.processingTime;
        
        updateWorkerDisplays();
        updateCounters();
        
        addLogEntry(`Request #${reqId} from ${request.clientIP} completed by Worker ${request.workerIndex} (PID: ${request.pid}) in ${request.processingTime}ms`, 'completed');
        
        delete activeRequests[reqId];
      }
    }
    
    // Update worker displays
    function updateWorkerDisplays() {
      for (let i = 1; i <= 4; i++) {
        const workerElement = document.getElementById(`worker${i}`);
        const pid = workerPids[i];
        
        if (pid) {
          const load = workerLoads[pid] || 0;
          document.getElementById(`load-${i}`).textContent = `${load} ms`;
          
          // Update status based on load
          const status = load > 0 ? 'busy' : 'idle';
          workerElement.className = `worker ${status}`;
          workerElement.querySelector('.status').textContent = status.charAt(0).toUpperCase() + status.slice(1);
          workerElement.querySelector('.status-indicator').className = `status-indicator ${status}`;
        }
      }
    }
    
    // Start spam
    function startSpam() {
      if (spamInterval) return;
      
      document.getElementById('startSpamBtn').disabled = true;
      document.getElementById('stopSpamBtn').disabled = false;
      
      spamInterval = setInterval(sendRequest, 1000);
      addLogEntry('Started sending repeated requests', 'sent');
    }
    
    // Stop spam
    function stopSpam() {
      clearInterval(spamInterval);
      spamInterval = null;
      
      document.getElementById('startSpamBtn').disabled = false;
      document.getElementById('stopSpamBtn').disabled = true;
      
      addLogEntry('Stopped sending repeated requests', 'sent');
    }
    
    // IP selection change handler
    document.getElementById('clientIP').addEventListener('change', function() {
      const clientIP = this.value;
      updateHashDetails(clientIP);
    });
    
    // Initial setup
    window.onload = function() {
      const initialIP = document.getElementById('clientIP').value;
      updateHashDetails(initialIP);
    };
  </script>
</body>
</html>